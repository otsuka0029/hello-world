# ソフトウェア工学の内容まとめ
## 第一回
### ソフトウェア工学の難しいところ
- **実務から体系化された知見**  
ソフトウェア開発に携わった経験がないとイメージが湧かない  
- **知見と実践の乖離**  
知見を理解せても実践することが難しい  
- **個々人のソフトウェア工学の知識だけでは不十分**  
チーム全体で共有する必要がある  
### LLMがソフトウェアをつくる？  
- **AI Agentによるソフトウェア開発**  
・要件定義，バージョン管理，テストが不可欠  
・監督者としての能力（＝ソフトウェア工学）が求められる  
## 第二回  ソフトウェア工学概論  
### ソフトウェア  
- **「情報を」扱うプロダクトそのもの，プロダクトを提供する手段**  
### ソフトウェアの定義
1. **実行されることによって必要な特性，機能，性能を提供する命令語群（コンピュータプログラム）**  
2. **プログラムが適切に情報を扱うことを可能とするデータ構造**  
3. **プログラムの操作や使用法を記述した情報**  
### ソフトウェアの特徴
- **新しい環境や技術のニーズを満たすよう適応しなければならない**  
- **新しいビジネス要求を実現するために強化されなければならない**  
- **より近代的なシステムやデータベースと相互運用するため拡張されなければならない**  
- **進化し続ける環境で実行可能となるよう，再構築されなければならない**  
### ソフトウェア工学
- **ゴール**  
「進化論に基づく （ソフトウェアシステムが変化し続ける状況に対応する）方法論を考え出すことである。 新しいソフトウェアが古いシステムから構築され、すべては互換性を持ち、他システムと相互運用しなければならない」
- **定義**  
「ソフトウェアの開発、運用、メンテナンスに対するシステマ  ティックで規律（discipline）ある、定量化できるアプローチの適用、すなわちソフトウェアに対するエンジニアリングの適用」（IEEE） 
- **必要性**
1. **大規模化と複雑さ**  
ソフトウェアを効率よく開発し，メンテナンスする必要がある  
2. **IT人材の不足**  
ソフトウェアを効率的に開発・管理することのできる人材が少ない  
3. **社会性と求められるミッション**  
ライフライン・インフラストラクチャーとしてのソフトウェアが増加  
4. **不確実性の増大**  
ソフトウェア利用の変化・多様化  
ニーズに対応したソフトウェアの開発  
### プラクティスの本質
1. **問題を理解する（コミュニケーションと分析）**  
2. **解決策を計画する（モデリングとソフトウェア設計）**  
3. **計画を実行に移す（コード実装）**  
4. **結果が正しいことを理解する（テストと品質保証）**  
### Hookerの７原則
1. **システムが存在する唯一の理由**  
システムはユーザに価値を提供するためにある  
2. **シンプルにしておけ！（KISS: Keep It Simple, Stupid!）**  
すべての設計は可能な限りシンプルであるべき  
3. **ビジョンを持ち続けよ**  
ソフトウェアプロジェクトの成功には明確なビジョンが不可欠である  
4. **あなたの作ったものを他の人が使用する**  
あなたのやっていることを他人が理解しなければならないということを常に考えながら仕様を決め、設計し、ドキュメントを書き、実装するべきである。  
5. **未来へオープンであれ**  
コンピュータ環境の仕様変更に対応すべく、一般的な問題を解決するシステムを構築して、可能な限り多くの選択肢を与えられるよう準備しておく。  
6. **再利用に先駆けて計画せよ**  
コストを低減し、再利用するコンポーネントとそれを取り込むシステムの両方の価値を高める。  
7. **考えよ！**  
行動を起こす前に簡潔明瞭な考えをもつことは、必ずと行ってよいほどよい結果を生む。  
### Hyrumの法則
- **あるAPIに十分な数のユーザーがいるとき、APIを作った者自身が契約仕様として何を約束しているかは重要ではない。作られたシステムが持つあらゆる観察可能 （observable）な挙動に関して、それに依存するユーザーが出てくるものである。**
## 第三回 ソフトウェアライフサイクル
### ソフトウェアライフサイクル  
- **ソフトウェアの誕生**  
・ニーズの発生
・ビジネス上あるいはシステム上の要求をぐげんかするための企画・計画を行う  
・要件定義  
- **ソフトウェアの開発・運用**  
・ソフトウェアの開発  
・実稼働  
・保守運用  
- **ソフトウェアの廃止**  
・サービスの終了  
・新規ソフトウェアへのリニューアル  
### 要件定義
- **内容**  
・システムの目的  
・システムの概要  
・システムの機能  
・システム構成（システム構成図，ソフトウェアブロック図）  
・目標性能  
・他システムとインターフェイス仕様  
・運用面の注意事項  
・制限事項  
・拡張性  
・開発スケジュール  
・開発体制  
・納品物  
- **意義**  
・プロジェクト関係者のバイブル  
・社内外への宣言と協力依頼  
・Request for Proposal（RFP）  
### 設計  
- **要件定義書から設計書へ**  
- **コーディングが出来るレベルの仕様書に落とし込む**  
・クラス，モジュール  
- **WBS(Work Breakdown Structure)**  
### 制作  
- **設計書に従ってシステム構築**  
- **内製（自社開発）**  
・一部機能を機能をパッケージとして購入したり、外部委託することも  
- **調達(外部委託)**  
・開発を外部に委託  
・ソースコードを納品物に含める場合，メンテナンスは自社で可能  
・含めない場合，メンテナンスは作業委託契約を締結する必要がある  
### オフショア開発  
- **賃金の安い海外企業に外部委託する手法**  
- **注意事項**  
・文化の違い  
・言語の違い  
・商習慣の違い  
・品質に対する意識の違い  
### テストとデバッグ  
- **バグのないソフトウェアはない**  
- **あらかじめテストしバグを早期に発見・対処することが理想**  
- **全てをテストすることは不可能**  
・ソフトウェアのどの個所をテストするか？  
・どの程度テストするか？  
### 運用・保守  
- **稼働後のデータをプロアクティブに活用するべき**  
- **ソフトウェア以外の要因も考慮する必要がある**  
- **開発者はプロジェクトから離れている可能性がある**  
### ドキュメンテーション  
- **複数人でのソフトウェア開発**  
- **非同期コミュニケーション**  
## ソフトウェア工学４
- ## プロジェクト
### プロジェクトとは？  
- **有限性**  
・必ず終わりがある類の仕事  
- **独自性**  
・独自の目的を達成する類の仕事  
### フォアキャスティング・バックキャスティング  
- **フォアキャスティング**  
・インプット視点  
・今の立ち位置から順に目標に進んでいく  
- **バックキャスティング**  
・アウトプット視点  
・定めた目標に向けて何が必要かを計画し達成に向かう  
- ## ソフトウェア分析  
### ソフトウェアを見える化するための手法  
- **ソフトウェアの物量に関する分析**  
- **ソフトウェアの実行性能に関する分析**  
- **ソフトウェアの開発工数に関する分析**  
- **ソフトウェアの品質に関する分析**  
### QCDの優先度  
- **品質優先**  
・人命に影響があるようなシステム  
- **費用優先**  
・公共関連システム  
- **納期優先**  
・イベント行事関連システム  
### ソフトウェアの評価
1. **コードの物量（ステップ数）**  
2. **コードの物量（オブジェクト容量）**  
### ソフトウェアの品質管理  
- **「バグがない」はどう証明する**  
・計画していたテストではすべてバグは対応した  
・まだバグが確認されていない  
- **「Hyrumの法則」を想定するべき**  
### ソフトウェアをいつリリースするべきか？  
- **バグを最小化した状態でリリースするか？**  
- **リリース後にバグに対応するか？**  
- **「Hyrumの法則」を想定するべき**  
### バグ発生率  
- **１ステップ数（改行を除いたコード行数）あたりの発生バグ数**  
### ソフトウェアの評価
3. **ファンクションポイント（FP）法**  
・プログラミングフェーズに入る前にユーザー要件が定まり，必要な機能が見えてきた段階でシステム規模を概算することができる．  
・システム調達の際の異なるシステムの規模を比較，新規開発するか購入するかなどの投資意思決定の指標にも利用できる．  
4. **使い勝手**  
1）画面の視認性  
2）操作性  
3）入力補助  
4）互換性  
5）ガイダンス  
- ## 開発プロセス  
### ウォーターフォール型開発プロセス  
- **進捗管理が容易，成果物が明確**  
- **後工程にしわ寄せが集中というリスクあり**  
### スパイラルモデル  
- **プログラム開発を小さなフェーズに分割**  
- **フェーズごとにプロトタイプによるデモンストレーション→フィードバック**  
- **プロトタイプ作成に想定外の作業量が発生するリスクあり**  
### 反復型開発プロセス  
- **ソフトウェアを機能分割し，これを「反復」と呼ぶ単位で管理する**  
・積み上げ方式  
- **メリット**  
・部分的に完成させていくので，顧客の要求を取り入れやすい  
・部分的な納品が可能  
- **デメリット**  
・分割のための作業や管理業務が増える  
・全体像が見えづらい  
・一括して稼働するシステムは分割しても意味がなくなってしまう  

